// Generated by CoffeeScript 1.6.3
(function() {
  var NO_WORK_ERROR, Task, TaskQueue, async, domain, fetch, fetchTask, fetchTaskLimit, http, oi, path, saveTask, url, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  domain = require("domain");

  http = require("http");

  url = require("url");

  path = require("path");

  _ = require("lodash");

  async = require("async");

  oi = require("oibackoff");

  NO_WORK_ERROR = "No work available to process";

  saveTask = function(taskResourceUrl, task, secToken, callback) {
    var headers, options, save_request, taskUrl;
    taskUrl = url.parse(taskResourceUrl);
    headers = {
      'secToken': secToken,
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    };
    options = {
      headers: headers,
      hostname: taskUrl.hostname,
      port: taskUrl.port,
      path: taskUrl.path,
      method: task.rpmRId ? "PUT" : "POST"
    };
    save_request = http.request(options, function(save_response) {
      var data;
      data = "";
      save_response.addListener("data", function(chunk) {
        return data += chunk;
      });
      save_response.addListener("end", function() {
        if (callback) {
          return callback(null, data);
        }
      });
      return save_response.addListener("error", function(error) {
        if (callback) {
          return callback(error);
        }
      });
    });
    save_request.write(JSON.stringify(task));
    return save_request.end();
  };

  fetchTask = function(taskResourceUrl, taskType, secToken, callback) {
    var taskUrl;
    taskUrl = url.parse(taskResourceUrl);
    taskUrl.path = taskUrl.path + "/dequeue/" + taskType;
    return fetch(taskUrl, secToken, callback);
  };

  fetchTaskLimit = function(taskResourceUrl, taskType, limit, secToken, callback) {
    var taskUrl;
    taskUrl = url.parse(taskResourceUrl);
    taskUrl.path = taskUrl.path + "/dequeue/" + taskType + "?limit=" + limit;
    return fetch(taskUrl, secToken, callback);
  };

  fetch = function(taskUrl, secToken, callback) {
    var fetch_request, headers, options;
    headers = {
      'secToken': secToken,
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    };
    options = {
      headers: headers,
      hostname: taskUrl.hostname,
      port: taskUrl.port,
      path: taskUrl.path,
      method: "GET"
    };
    fetch_request = http.request(options, function(fetch_response) {
      var data;
      data = "";
      fetch_response.addListener("data", function(chunk) {
        return data += chunk;
      });
      fetch_response.addListener("end", function() {
        var taskObj;
        if (callback) {
          if (fetch_response.statusCode === 200) {
            taskObj = JSON.parse(data);
            if (!taskObj || _.isEmpty(taskObj) || (taskObj.hasOwnProperty("task") && _.isEmpty(taskObj.task))) {
              return callback(NO_WORK_ERROR);
            } else {
              return callback(null, taskObj);
            }
          } else {
            return callback(data);
          }
        }
      });
      return fetch_response.addListener("error", function(error) {
        if (callback) {
          return callback(error);
        }
      });
    });
    return fetch_request.end();
  };

  Task = (function() {
    function Task(taskType, data, taskResourceUrl, secToken, options) {
      this.complete = __bind(this.complete, this);
      this.save = __bind(this.save, this);
      this.backoffMaxDelay = __bind(this.backoffMaxDelay, this);
      this.backoff = __bind(this.backoff, this);
      this.maxAttempts = __bind(this.maxAttempts, this);
      this.attempts = __bind(this.attempts, this);
      this.abandonDelay = __bind(this.abandonDelay, this);
      this.priority = __bind(this.priority, this);
      this.delay = __bind(this.delay, this);
      this.state = __bind(this.state, this);
      this.taskResourceUrl = taskResourceUrl;
      this.secToken = secToken;
      this.root = {
        progress: 0,
        state: "active",
        priority: "normal",
        abandonDelay: 60000,
        attempts: 0
      };
      this.root.taskType = taskType;
      this.root.data = data;
      if (options) {
        this.root = _.extend(this.root, options.task);
      }
      this.root;
    }

    Task.prototype.state = function(val) {
      this.root.state = val;
      return this;
    };

    Task.prototype.delay = function(val) {
      this.root.delayedUntil = val;
      return this;
    };

    Task.prototype.priority = function(val) {
      this.root.priority = val;
      return this;
    };

    Task.prototype.abandonDelay = function(val) {
      this.root.abandonDelay = val;
      return this;
    };

    Task.prototype.attempts = function(val) {
      this.root.attempts = val;
      return this;
    };

    Task.prototype.maxAttempts = function(val) {
      this.root.maxAttempts = val;
      return this;
    };

    Task.prototype.backoff = function(val) {
      this.root.backoff = val;
      return this;
    };

    Task.prototype.backoffMaxDelay = function(val) {
      this.root.backoffMaxDelay = val;
      return this;
    };

    Task.prototype.save = function(cb) {
      saveTask(this.taskResourceUrl, this.root, this.secToken, cb);
      return this;
    };

    Task.prototype.complete = function() {
      this.root.progress = 100;
      this.root.state = "complete";
      return this;
    };

    return Task;

  })();

  TaskQueue = (function() {
    function TaskQueue(options) {
      this.process = __bind(this.process, this);
      this.dequeueLimit = __bind(this.dequeueLimit, this);
      this.dequeue = __bind(this.dequeue, this);
      this.createTask = __bind(this.createTask, this);
      if (options) {
        this.taskResourceUrl = options.taskResourceUrl;
        this.secToken = options.secToken;
        this.log = options.log;
      }
      if (!this.taskResourceUrl || !this.secToken) {
        throw new Error("constructor requires taskResourceUrl and secToken options");
      }
    }

    TaskQueue.prototype.createTask = function(taskType, data, options) {
      var task;
      return task = new Task(taskType, data, this.taskResourceUrl, this.secToken, options);
    };

    TaskQueue.prototype.dequeue = function(taskType, cb) {
      return fetchTask(this.taskResourceUrl, taskType, this.secToken, cb);
    };

    TaskQueue.prototype.dequeueLimit = function(taskType, limit, cb) {
      return fetchTaskLimit(this.taskResourceUrl, taskType, limit, this.secToken, cb);
    };

    TaskQueue.prototype.process = function(taskType, options, fn) {
      var initProcess, log, processDomain,
        _this = this;
      processDomain = domain.create();
      log = options.log || this.log;
      processDomain.on("error", function(err) {
        if (options.rethrowErrors) {
          throw err;
        } else {
          if (log != null) {
            log.error("Untrapped Error", err);
          }
          return setTimeout(function() {
            return initProcess();
          }, 10000);
        }
      });
      initProcess = function() {
        return processDomain.run(function() {
          var asyncQ, doFetch, procObj;
          options || (options = {});
          options.concurrency || (options.concurrency = 1);
          options.maxDelay || (options.maxDelay = 300);
          doFetch = function() {
            var backoff, getWork, intermediate;
            getWork = function(cb) {
              return fetchTask(_this.taskResourceUrl, taskType, _this.secToken, cb);
            };
            backoff = oi.backoff({
              algorithm: 'fibonacci',
              delayRatio: 1,
              maxDelay: options.maxDelay,
              maxTries: 1000000
            });
            intermediate = function(err, tries, delay) {
              var e;
              if (err && err !== NO_WORK_ERROR) {
                return true;
              } else {
                try {
                  if (options.maxDelay < delay) {
                    delay = options.maxDelay;
                  }
                } catch (_error) {
                  e = _error;
                  if (log != null) {
                    log.warn(e, "Error calculating intermediate stats");
                  }
                }
                if (log != null) {
                  log.info("Backing off after " + tries + " tries with delay " + delay);
                }
                return true;
              }
            };
            return backoff(getWork, intermediate, function(err, task) {
              return asyncQ.push(task);
            });
          };
          asyncQ = async.queue(function(task, callback) {
            var wrappedTask;
            if (_.isEmpty(task)) {
              return callback(NO_WORK_ERROR);
            } else {
              wrappedTask = new Task(task.taskType, task.taskData, _this.taskResourceUrl, _this.secToken, task);
              return fn.apply(_this, [
                wrappedTask, function(err, resultTask) {
                  if (err) {
                    wrappedTask.root.error = err.message || err;
                    return wrappedTask.save(callback);
                  } else {
                    return wrappedTask.complete().save(callback);
                  }
                }
              ]);
            }
          }, options.concurrency);
          asyncQ.empty = doFetch;
          doFetch();
          return procObj = {
            pause: asyncQ.pause,
            resume: asyncQ.resume,
            kill: asyncQ.kill,
            stop: asyncQ.kill,
            drain: asyncQ.drain
          };
        });
      };
      return initProcess();
    };

    return TaskQueue;

  })();

  module.exports = TaskQueue;

}).call(this);
